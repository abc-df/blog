---
title: 堆排序
tags: java
key: 
modify_date: 2019-07-12 20:00:00 +08:00
---



## 算法思想
堆的结构可以分为大根堆和小根堆，是一个完全二叉树(除了最后一层可能有一个节点，其余都是两个节点)，而堆排序是根据堆的这种数据结构设计的一种排序。
不完全二叉树用链表来存储，如果用数组会中间会出现空的元素。
1. 初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大

![image](https://longdeja.github.io/blog/u=1795207144,326722603&fm=26&gp=0.jpg)

2. 然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆

3. 依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列


把9和0互换位置，

<!--more-->
##大顶堆和小顶堆定义

大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]

小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2] 



## 性能
适合处理数据量大的序列，例如从1000万数据中取前100个数，只需要维持一个100的小顶堆。将剩下的树和遍历和小顶锥进行比较

## java代码
```java

    public class HeapSort {

        public static void main(String[] args) {
            int[] a = {1, 3, 4, 5, 2, 6, 9，7，8，0};

            System.out.println("排序前：" + Arrays.toString(a));

            heapSort(a);

            System.out.println("排序后：" + Arrays.toString(a));

        }
        //堆排序
        public static void heapSort(int[] arr) {
            //构造大根堆
            heapInsert(arr);
            int size = arr.length;
            while (size > 1) {
                //固定最大值
                swap(arr, 0, size - 1);
                size--;
                //构造大根堆
                heapify(arr, 0, size);

            }

        }

        //构造大根堆（通过新插入的数上升）
        public static void heapInsert(int[] arr) {
            for (int i = 0; i < arr.length; i++) {
                //当前插入的索引
                int currentIndex = i;
                //父结点索引
                int fatherIndex = (currentIndex - 1) / 2;
                //如果当前插入的值大于其父结点的值,则交换值，并且将索引指向父结点
                //然后继续和上面的父结点值比较，直到不大于父结点，则退出循环
                while (arr[currentIndex] > arr[fatherIndex]) {
                    //交换当前结点与父结点的值
                    swap(arr, currentIndex, fatherIndex);
                    //将当前索引指向父索引
                    currentIndex = fatherIndex;
                    //重新计算当前索引的父索引
                    fatherIndex = (currentIndex - 1) / 2;
                }
            }
        }
        //将剩余的数构造成大根堆（通过顶端的数下降）
        public static void heapify(int[] arr, int index, int size) {
            int left = 2 * index + 1;
            int right = 2 * index + 2;
            while (left < size) {
                int largestIndex;
                //判断孩子中较大的值的索引（要确保右孩子在size范围之内）
                if (arr[left] < arr[right] && right < size) {
                    largestIndex = right;
                } else {
                    largestIndex = left;
                }
                //比较父结点的值与孩子中较大的值，并确定最大值的索引
                if (arr[index] > arr[largestIndex]) {
                    largestIndex = index;
                }
                //如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环
                if (index == largestIndex) {
                    break;
                }
                //父结点不是最大值，与孩子中较大的值交换
                swap(arr, largestIndex, index);
                //将索引指向孩子中较大的值的索引
                index = largestIndex;
                //重新计算交换之后的孩子的索引
                left = 2 * index + 1;
                right = 2 * index + 2;
            }

        }
        //交换数组中两个元素的值
        public static void swap(int[] arr, int i, int j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }

}


```



