---
title: RSA加密
tags: java
key: 
modify_date: 2019-08-08 20:00:00 +08:00
---

# RSA介绍（百度）
RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。
1973年，在英国政府通讯总部工作的数学家克利福德·柯克斯（Clifford Cocks）在一个内部文件中提出了一个相同的算法，但他的发现被列入机密，一直到1997年才被发表。
对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破。到目前为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。
1983年麻省理工学院在美国为RSA算法申请了专利。这个专利2000年9月21日失效。由于该算法在申请专利前就已经被发表了，在世界上大多数其它地区这个专利权不被承认。

 <!--more-->

 ## RSA加密
 RSA的安全基于大数分解的难度。其公钥和私钥是一对大素数（100到200位十进制数或更大）的函数。从一个公钥和密文恢复出明文的难度，等价于分解两个大素数之积（这是公认的数学难题）。
 
 当p和q是一个大素数的时候，从它们的积pq去分解因子p和q，这是一个公认的数学难题。比如当pq大到1024位时，迄今为止还没有人能够利用任何计算工具去完成分解因子的任务。因此，RSA从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。
 
 但并没有从理论上证明破译RSA的难度与大数分解难度等价。即RSA的重大缺陷是无法从理论上把握它的保密性能如何。

 ![image](https://longdeja.github.io/blog/image/1565231023(1).png)

 ## RSA加密缺点

 1. 产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。
 2. 分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。因此，使用RSA只能加密少量数据，大量的数据加密还要靠对称密码算法。

 ## JAVA代码
```java
 package com.gongshi.web.citic.common.util;

import org.springframework.core.io.ClassPathResource;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.io.*;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class RSAEncryptUtils {

    private static final int RSA_KEYSIZE = 1024;

    // RSA算法对文件加密
    public static void encryptByRSA(String fileName, String saveFileName, String publicKey) throws Exception {
        try {
            byte[] decoded = Base64.getDecoder().decode(publicKey);
            KeyGenerator keygen = KeyGenerator.getInstance("AES");
            SecureRandom random = new SecureRandom();
            keygen.init(random);
            SecretKey key = keygen.generateKey();
            RSAPublicKey key2 = (RSAPublicKey) KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(decoded));
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.WRAP_MODE, key2);
            byte[] wrappedKey = cipher.wrap(key);
            DataOutputStream out = new DataOutputStream(new FileOutputStream(saveFileName));
            out.writeInt(wrappedKey.length);
            out.write(wrappedKey);
            InputStream in = new FileInputStream(fileName);
            cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.ENCRYPT_MODE, key);
            crypt(in, out, cipher);
            in.close();
            out.close();
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // RSA算法对文件解密
    public static void decryptByRSA(String fileName, String saveFileName, String privateKey) throws Exception {
        try {
            DataInputStream in = new DataInputStream(new FileInputStream(fileName));
            int length = in.readInt();
            byte[] wrappedKey = new byte[length];
            in.read(wrappedKey, 0, length);
            byte[] decoded = Base64.getDecoder().decode(privateKey);
            RSAPrivateKey key2 = (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(decoded));

            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.UNWRAP_MODE, key2);
            Key key = cipher.unwrap(wrappedKey, "AES", Cipher.SECRET_KEY);

            OutputStream out = new FileOutputStream(saveFileName);
            cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.DECRYPT_MODE, key);

            crypt(in, out, cipher);
            in.close();
            out.close();
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //对数据块加密
    public static void crypt(InputStream in, OutputStream out, Cipher cipher) throws IOException, GeneralSecurityException {
        int blockSize = cipher.getBlockSize();
        int outputSize = cipher.getOutputSize(blockSize);
        byte[] inBytes = new byte[blockSize];
        byte[] outBytes = new byte[outputSize];

        int inLength = 0;
        boolean next = true;
        while (next) {
            inLength = in.read(inBytes);
            if (inLength == blockSize) {
                int outLength = cipher.update(inBytes, 0, blockSize, outBytes);
                out.write(outBytes, 0, outLength);
            } else {
                next = false;
            }
        }
        if (inLength > 0) {
            outBytes = cipher.doFinal(inBytes, 0, inLength);
        } else {
            outBytes = cipher.doFinal();
        }
        out.write(outBytes);
    }

    //生成RSA密钥对
    public static void generateRSAKey() {
        try {
            KeyPairGenerator keygen = KeyPairGenerator.getInstance("RSA");
            SecureRandom random = new SecureRandom();
            keygen.initialize(RSA_KEYSIZE, random);
            KeyPair keyPair = keygen.generateKeyPair();
            RSAPublicKey puk = (RSAPublicKey) keyPair.getPublic();
            String publicKeyString = Base64.getEncoder().encodeToString(puk.getEncoded());
            System.out.println("publicKeyString=================:" + publicKeyString);
            RSAPrivateKey prk = (RSAPrivateKey) keyPair.getPrivate();
            String privateKeyString = Base64.getEncoder().encodeToString(prk.getEncoded());
            System.out.println("privateKeyString=================:" + privateKeyString);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        //生成公钥和私钥
        //RSAEncryptUtils.generateRSAKey();
        //对文件进行加密
        //RSAEncryptUtils.encryptByRSA("C://Users//xtong//Desktop//12345678.txt", "C://Users//xtong//Desktop//1234567833.txt", loadKeyByFile(" publicKey-gssx.key"));
        //对文件进行解密
        RSAEncryptUtils.decryptByRSA("C://Users//xtong//Desktop//GSSXTEST_20190731.csv", "C://Users//xtong//Desktop//GSSXTEST_2019073111111111.csv", "MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALMTruJ85VwP+RqedpjR5l7+a2X3bhLShoIP1ufbZ6hdbEqwW8OCYPJLDq5xRFcXKXqCYto/+XTVA6bM1nJtXvtKiL2CdZrhKT2n+FIYCTUnYzZ9EQ6jFkkQU3Z6wY7aMhM7oo4adEdj3VteCgYqjUHYxNsz65Bh6sDS+YOcNg8pAgMBAAECgYBI1WWYypGCmyCG2hKEX0KiOjo2M6d6UlPQzF5s2MjVKoIj8oyv/PQvN6XV/017WnlNUYChIcn04bplegRyb9dkEH1D4sqwu0YxPzE/SVQKxVLlEASDXkHTGBB6O6W+XtWXMsBbSEpJQdH1MiwIWlrDjknePWQvWuH/Oxgnp7JrgQJBAOmYnQkhw+DEJ5p3tZm1QsSgzFHkEp92JjepNyXajrwndRNLc3rtW4c3DF0PbwY8s9a1bkDcOa/CH+AJTSTtifECQQDEQHtKbLWvVgzxu11+dY+ByzfTA2KKjZi9LpI74jUxuIo8NL1mB+QSZvzqW9jcFJFXF39libVOZ/UtTKLrA2C5AkBtt67aoS9dnQR0+xEi9w47SMNvG07b8ySUNDig4Pz1xxqoS2IcNOwuoF6AP0WIim51xJXahRXbRbSvB+9iDughAkAmXy08GhFUHREe2rGnHjlW+XMK0SidSp5IryhsiQg5lomAyBcYMgbIClb9Q8QdE/BvBOsl4U0P7Yekuc1JAjoRAkEAiWTj46K3ZuIAONKkaDSwoL6WQICcptHgofi5waj6A4dfVOM6GDGzo4zVF14LUEp3/o0Gcu3CSRWUk6NmLmREHQ==");

    }

    /**
     * 功能描述: 从文件中加载钥串
     *
     */
    public static String loadKeyByFile(String path) throws Exception {
        ClassPathResource resource = new ClassPathResource(path);
        InputStream inputStream = resource.getInputStream();
        InputStreamReader reader = new InputStreamReader(inputStream, "UTF-8");
        BufferedReader br = new BufferedReader(reader);
        String readLine = null;
        StringBuffer sb = new StringBuffer();
        while ((readLine = br.readLine()) != null) {
            sb.append(readLine);
        }
        br.close();
        return sb.toString();
    }
}

```
