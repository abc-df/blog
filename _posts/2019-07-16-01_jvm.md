---
title: jvm
tags: java
key: 
modify_date: 2019-07-16 20:00:00 +08:00
---

# Java Virtual Machine

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

 <!--more-->

jvm的内存分布在操作系统的堆中。如果存在栈中，不能确定被谁回收。

2.JVM的体系结构：

1） 类装载器（ClassLoader）（用来装载.class文件）

2） 执行引擎（执行字节码，或者执行本地方法）

3） 运行时数据区（方法区、堆、虚拟机栈、程序计数器、本地方法栈）

![image](https://longdeja.github.io/blog/image/jvm结构图.jpg)

## 所有线程共享

### 方法区：

用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
当方法区无法满足内存的分配需求时，报OutOfMemoryError异常，方法区中有一个运行时常量池，用于存储编译期生成的各种字面量与符号引用，当常量池无法再申请到内存时报OutOfMemoryError异常。
 
方法区内部结果包括：

 （1） 运行时常量池：常量池中存放的是该类型所用到的常量的有序集合，包括直接常量和对其它类型，字段和方法的符号引用，这个常量池像数组一样通过索引来引用，在动态链接中心起着核心作用。

 （2） 类型信息： 类型的完全限定名、类型直接超类的完全限定名、直接超接口的全限定名列表、该类型是类类型还是接口类型、类型的访问修饰符

 （3） 字段信息：注意区别常量池中字段引用和这里的字段信息，字段信息是指该类中声明的所有字段（包括类级变量和实例变量，不包括局部变量）的描述，如字段名称、字段修饰符等。具体如下

      1.字段名
      2.字段的类型
      3.字段的修饰符

 （4） 方法信息：方法名、方法的返回类型、方法参数的个数和类型顺序、方法的修饰符、字符的字节码、操作数栈和该方法在栈帧中的局部变量区大小等、异常类。
 
 （5） 类变量： 在类中使用static修饰的变量叫类变量。类白能量是所有对象共享，所以保存在方法区中。类变量分为两种变量：
 
    1非编译时变量：在虚拟机使用某类前，必须为此类变量分配内存空间
    2编译时变量：对于编译时的常量，则直接将其复制到使用他们的类的常量池中，或者作为字节码流的一部分。
 
 （6）指向类加载器的引用：一个类可以被启动类加载器或者自定义的类加载器加载，如果一个类被某个自定义类加载器的对象加载，则方法区中必须保存对该对象的引用。
 
 （7）指向class实例的引用：在加载过程中，虚拟机会创建一个代表该类型的class对象，方法区中必须保存对该对象的引用。
 
 （8）方法表：为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，jvm的实现者还可以添加一些其它的数据结构，如方法表，jvm对每个加载的非虚拟类的类型信息添加了一个方法表，方法表时一组对类实例方法的直接引用。jvm可以通过方法表快速激活实例方法。

### 堆(Heap)：

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 此区域的唯一目的就是存放对象实例，几乎所有对象的实例都在这分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（ Automatic Storage Management System，也即是常说的“ Garbage Collector（垃圾收集器）”）所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁。 Java 堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。

## 线程私有

### 虚拟机栈：

线程私有，声明周期与线程同步。

存储一些方法的局部变量表（基本类型、对象引用）、操作数栈、动态链接、方法出口等信息。

每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建的时候被创建。

每个方法执行的同时都会创建一个栈帧，每个方法被调用直至完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

当线程请求的栈深度大于虚拟机允许的深度时报StackOverFlowError异常。

当栈的扩展无法申请到足够的内存时报OutOfMemoryError异常。

栈帧（stack frame）的内部结构：

  （1）局部标量表：

  （2）操作数栈：

  （3）动态链接：

  （4）方法出口：

  （5）其它信息


### 本地方法栈：

主要是为虚拟机使用到的Native方法服务，Native 方法就是一个java调用非java代码的接口，该方法的实现由非java语言实现。Native方法用native修饰，没有方法体，因为方法体中的实现是非java语言的。

有时java需要调用操作系统的一些方法，而操作系统基本都是C语言写的，这时就需要使用到Native方法了。

Native方法关键字修饰的方法是一个原生态的方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI（Java Native Interface）接口调用其他语言来实现对底层的访问。

### 程序计数器：

当前线程所执行的字节码的行号指示器，当前线程私有，由于他只是存储行号，一般就是一个数字，所以不会出现OutOfMemoryError异常。

其特点是：如果正在执行java方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址，如果正在执行Native方法，则这个计数器为空（undefined），此内存区域是唯一一个在java虚拟机中没有规定任何OutOfMemoryError异常情况的区域。

使用场景：A线程先获取CPU时间片执行，当执行到一半的时候，B线程过来了，且优先级比A线程的高，所以处理器又去执行B线程了，把A线程挂起，当B线程执行完了以后，再回过头来执行A线程，这时就需要知道A线程已经执行的位置，也就是查看A中的程序计数器中的指令。

 

总结：java对象存放在堆中，常量存放在方法区的常量池中，虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据放在方法区，以上区域都是线程共享的。栈是线程私有的，存放该方法的局部变量（基本类型、对象引用）操作数栈、动态链接、方法出口等信息。一个java程序对应一个JVM，一个方法对应一个java栈。


      静态变量+常量+类信息+运行时常量池存在方法区中，实例变量存在堆内存中。
      基本类型的变量和对象的引用变量都是在函数的栈内存中分配。

# 垃圾回收机制(GC)

## JVM的垃圾回收的算法

### 标记-清除算法(Mark-Sweep)

标记清除算法是最基础的回收算法，该算法分为两个阶段，即标记阶段和清除阶段。

缺点：

    效率问题：标记和清理的效率都不高
    空间问题：造成很多不连续的空间，如果要存储大对象，从而不得不提前触发GC回收操作

### 复制算法(Copying)

复制算法是为了解决标记清除算法效率不高的问题而产生的，该算法的思路是。将内存空间一分为二(大小相等)。每次只使用其中一块来存储对象，当一块内存使用的差不多的时候就将这块中还存活的对象就复制到另一块内存中，然后清理掉已经使用过的那块内存。

有点：不存在内存碎片问题

缺点：空间减少一半

### 标记-整理算法(Mark-Compact)

标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题

### 分代收集算法

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

1. 新生代通常存活时间较短，因此基于复制算法来进行回收，所谓复制算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中.
2. 老年代的对象存活时间比较长，采用标记-清除算法


#方法区，栈、堆之间的过程

类加载器加载的类信息放到方法区，--》执行程序后，方法区的方法压如栈的栈顶--》栈执行压入栈顶的方法--》遇到new对象的情况就在堆中开辟这个类的实例空间。（这里栈是有此对象在堆中的地址的）



# JVM 参数选项 
![image](https://longdeja.github.io/blog/image/jvm参数配置.png)




# 参考文章

1. https://www.runoob.com/go/go-tutorial.html

2. https://www.cnblogs.com/alsf/p/9017447.html

3. https://cloud.tencent.com/developer/article/1409311

4. https://www.sohu.com/a/289361529_100012573
