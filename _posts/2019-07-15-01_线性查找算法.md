---
title: BFPRT(线性查找算法)
tags: java
key: 
modify_date: 2019-07-15 20:00:00 +08:00
---



## 算法思想
BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分 析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂 度，五位算法作者做了精妙的处理。

 <!--more-->




## 算法步骤
1. 将n个元素每5个一组，分成n/5(上界)组。

2. 取出每一组的中位数，任意排序方法，比如插入排序。

3. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。

4. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。

5. 若i==k，返回x；若i< k，在小于x的元素中递归查找第i小的元素；若i>k，在大于x的元素中递归查找第i-k小的元素。

终止条件：n=1时，返回的即是i小元素。

## java代码
```java

    public class BfprtSearch {

        public static void main(String args []){
            int [] array ={4,45,32,67,5,78,4556,781,1,3,43,765,9,22};
            //查找第5小的元素
            int k_Num= quickSearch( array,0, array .length-1, 5);
            System. out .println(" 第 5 小的元素是： " +k_Num );
        }
        public static int quickSearch( int []array , int left, int right, int k){
            //left,right为下标， k 为第k 小的元素
            if( left== right){
                return array [left ];
            }
            int mid =getArrayMid (array , left, right); //mid 为中位数 id
            int mid_new =partition (array , left, right, mid );// 根据中位数划分数组，是中位数在最终的位置上
            // 比较中位数与要查找数值的大小
            if( mid_new== k-1){
                return array [mid_new ];
            } else if (mid_new <k -1){
                left= mid_new+1;
                return quickSearch( array, left, right, k);
            } else {
                right= mid_new-1;
                return quickSearch( array, left, right, k);
            }
        }
        public static int getArrayMid( int a [], int l, int r){ //l,r均为数组下标 , 返回中位数的位置
            if( l== r){
                return l ;
            }
            int i =l ;
            for (;i <=r -l -5;i +=5){// 子数组的元素个数为 5 个时
                insertSort( a, i, i+4); //对当前的五个数数进行排序
                swap( a, l+( i- l)/5, i+2); //将所有中位数放在数组 array 的前几位上
            }
            if( i< r- l){
                insertSort( a, i, r- l);
                swap( a, l+( i- l)/5,( i+ r- l)/2); //将最后一组数的中位数放在数组 array 的前几位上
            }
            return getArrayMid( a, l, l+( i- l)/5); // 返回中位数的中位数的 id

        };
        public static int partition( int a [], int l, int r, int mid){
            int pivot =a [mid];
            while (l <r ){
                while (l <r && pivot<= a[ r]) r--;
                a[ l]= a[ r];
                while (l <r && pivot> a[ l]) l++;
                a[ r]= a[ l];
            }
            a[ l]= pivot;
            return l ;
        };
        public static void swap(int []a , int i , int j ){
            int temp= a[ i];
            a[ i]= a[ j];
            a[ j]= temp;
        }
        public static void insertSort( int a [], int l , int r ){ // 对下标为 l到 r之间的元素进行排序
            if( l< r){
                for( int i= l; i< r; i++){
                    int j= i+1;
                    int temp= a[ j];
                    while( j> l&& temp< a[ j-1]){
                        a[ j]= a[ j-1];
                        j--;
                    }
                    a[ j]= temp;
                }
            }
        }

}



```





